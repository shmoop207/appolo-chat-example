{
  "name": "busboy",
  "version": "0.0.14",
  "author": {
    "name": "Brian White",
    "email": "mscdex@mscdex.net"
  },
  "description": "A streaming parser for HTML form data for node.js",
  "main": "./lib/main",
  "dependencies": {
    "dicer": "0.1.6",
    "readable-stream": "1.1.x"
  },
  "scripts": {
    "test": "node test/test.js"
  },
  "engines": {
    "node": ">=0.8.0"
  },
  "keywords": [
    "uploads",
    "forms",
    "multipart",
    "form-data"
  ],
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/mscdex/busboy/raw/master/LICENSE"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/mscdex/busboy.git"
  },
  "readme": "Description\n===========\n\nA node.js module for parsing incoming HTML form data.\n\n\nRequirements\n============\n\n* [node.js](http://nodejs.org/) -- v0.8.0 or newer\n\n\nInstall\n=======\n\n    npm install busboy\n\n\nExamples\n========\n\n* Parsing (multipart) with default options:\n\n```javascript\nvar http = require('http'),\n    inspect = require('util').inspect;\n\nvar Busboy = require('busboy');\n\nhttp.createServer(function(req, res) {\n  if (req.method === 'POST') {\n    var busboy = new Busboy({ headers: req.headers });\n    busboy.on('file', function(fieldname, file, filename, encoding, mimetype) {\n      console.log('File [' + fieldname +']: filename: ' + filename + ', encoding: ' + encoding);\n      file.on('data', function(data) {\n        console.log('File [' + fieldname +'] got ' + data.length + ' bytes');\n      });\n      file.on('end', function() {\n        console.log('File [' + fieldname +'] Finished');\n      });\n    });\n    busboy.on('field', function(fieldname, val, valTruncated, keyTruncated) {\n      console.log('Field [' + fieldname + ']: value: ' + inspect(val));\n    });\n    busboy.on('end', function() {\n      console.log('Done parsing form!');\n      res.writeHead(303, { Connection: 'close', Location: '/' });\n      res.end();\n    });\n    req.pipe(busboy);\n  } else if (req.method === 'GET') {\n    res.writeHead(200, { Connection: 'close' });\n    res.end('<html><head></head><body>\\\n               <form method=\"POST\" enctype=\"multipart/form-data\">\\\n                <input type=\"text\" name=\"textfield\"><br />\\\n                <input type=\"file\" name=\"filefield\"><br />\\\n                <input type=\"submit\">\\\n              </form>\\\n            </body></html>');\n  }\n}).listen(8000, function() {\n  console.log('Listening for requests');\n});\n\n// Example output, using http://nodejs.org/images/ryan-speaker.jpg as the file:\n//\n// Listening for requests\n// File [filefield]: filename: ryan-speaker.jpg, encoding: binary\n// File [filefield] got 11971 bytes\n// Field [textfield]: value: 'testing! :-)'\n// File [filefield] Finished\n// Done parsing form!\n```\n\n* Parsing `multipart/form-data` & saving files. Keep track of the point where the files are all properly saved to disk.\n\n```javascript\nhttp.createServer(function(req, res) {\n  if (req.method === 'POST') {\n    var infiles = 0, outfiles = 0, done = false,\n        busboy = new Busboy({ headers: req.headers });\n    console.log('Start parsing form ...');\n    busboy.on('file', function(fieldname, file, filename, encoding, mimetype) {\n      ++infiles;\n      onFile(fieldname, file, filename, function() {\n        ++outfiles;\n        if (done)\n          console.log(outfiles + '/' + infiles + ' parts written to disk');\n        if (done && infiles === outfiles) {\n          // ACTUAL EXIT CONDITION\n          console.log('All parts written to disk');\n          res.writeHead(200, { 'Connection': 'close' });\n          res.end(\"That's all folks!\");\n        }\n      });\n    });\n    busboy.on('end', function() {\n      console.log('Done parsing form!');\n      done = true;\n    });\n    req.pipe(busboy);\n  }\n}).listen(8000, function() {\n  console.log('Listening for requests');\n});\n\nfunction onFile(fieldname, file, filename, next) {\n  // or save at some other location\n  var fstream = fs.createWriteStream(path.join(os.tmpDir(), path.basename(filename)));\n  file.on('end', function() {\n    console.log(fieldname + '(' + filename + ') EOF');\n  });\n  fstream.on('close', function() {\n    console.log(fieldname + '(' + filename + ') written to disk');\n    next();\n  });\n  console.log(fieldname + '(' + filename + ') start saving');\n  file.pipe(fstream);\n}\n```\n\n* Parsing (urlencoded) with default options:\n\n```javascript\nvar http = require('http'),\n    inspect = require('util').inspect;\n\nvar Busboy = require('busboy');\n\nhttp.createServer(function(req, res) {\n  if (req.method === 'POST') {\n    var busboy = new Busboy({ headers: req.headers });\n    busboy.on('file', function(fieldname, file, filename, encoding, mimetype) {\n      console.log('File [' + fieldname +']: filename: ' + filename);\n      file.on('data', function(data) {\n        console.log('File [' + fieldname +'] got ' + data.length + ' bytes');\n      });\n      file.on('end', function() {\n        console.log('File [' + fieldname +'] Finished');\n      });\n    });\n    busboy.on('field', function(fieldname, val, valTruncated, keyTruncated) {\n      console.log('Field [' + fieldname + ']: value: ' + inspect(val));\n    });\n    busboy.on('end', function() {\n      console.log('Done parsing form!');\n      res.writeHead(303, { Connection: 'close', Location: '/' });\n      res.end();\n    });\n    req.pipe(busboy);\n  } else if (req.method === 'GET') {\n    res.writeHead(200, { Connection: 'close' });\n    res.end('<html><head></head><body>\\\n               <form method=\"POST\">\\\n                <input type=\"text\" name=\"textfield\"><br />\\\n                <select name=\"selectfield\">\\\n                  <option value=\"1\">1</option>\\\n                  <option value=\"10\">10</option>\\\n                  <option value=\"100\">100</option>\\\n                  <option value=\"9001\">9001</option>\\\n                </select><br />\\\n                <input type=\"checkbox\" name=\"checkfield\">Node.js rules!<br />\\\n                <input type=\"submit\">\\\n              </form>\\\n            </body></html>');\n  }\n}).listen(8000, function() {\n  console.log('Listening for requests');\n});\n\n// Example output:\n//\n// Listening for requests\n// Field [textfield]: value: 'testing! :-)'\n// Field [selectfield]: value: '9001'\n// Field [checkfield]: value: 'on'\n// Done parsing form!\n```\n\n\nAPI\n===\n\n_Busboy_ is a _Writable_ stream\n\nBusboy (special) events\n-----------------------\n\n* **file**(< _string_ >fieldname, < _ReadableStream_ >stream, < _string_ >filename, < _string_ >transferEncoding, < _string_ >mimeType) - Emitted for each new file form field found. `transferEncoding` contains the 'Content-Transfer-Encoding' value for the file stream. `mimeType` contains the 'Content-Type' value for the file stream. Notice that when no file is attached to the field, (typeof filename === 'undefined'), the stream is 0-length but still requires draining to signal that the event was handled, otherwise the 'end' event will not fire. call stream.resume() to drain the stream.\n\n* **field**(< _string_ >fieldname, < _string_ >value, < _boolean_ >valueTruncated, < _boolean_ >fieldnameTruncated) - Emitted for each new non-file field found.\n\n* **partsLimit**() - Emitted when specified `parts` limit has been reached. No more 'file' or 'field' events will be emitted.\n\n* **filesLimit**() - Emitted when specified `files` limit has been reached. No more 'file' events will be emitted.\n\n* **fieldsLimit**() - Emitted when specified `fields` limit has been reached. No more 'field' events will be emitted.\n\n\n**Note:** The `stream` passed in on the 'file' event will also emit a 'limit' event (no arguments) if the `fileSize` limit is reached. If this happens, no more data will be available on the stream.\n\n\nBusboy methods\n--------------\n\n* **(constructor)**(< _object_ >config) - Creates and returns a new Busboy instance with the following valid `config` settings:\n\n    * **headers** - _object_ - These are the HTTP headers of the incoming request, which are used by individual parsers.\n\n    * **highWaterMark** - _integer_ - highWaterMark to use for this Busboy instance (Default: WritableStream default).\n\n    * **fileHwm** - _integer_ - highWaterMark to use for file streams (Default: ReadableStream default).\n\n    * **defCharset** - _string_ - Default character set to use when one isn't defined (Default: 'utf8').\n\n    * **limits** - _object_ - Various limits on incoming data. Valid properties are:\n\n        * **fieldNameSize** - _integer_ - Max field name size (Default: 100 bytes).\n\n        * **fieldSize** - _integer_ - Max field value size (Default: 1MB).\n\n        * **fields** - _integer_ - Max number of non-file fields (Default: Infinity).\n\n        * **fileSize** - _integer_ - For multipart forms, the max file size (Default: Infinity).\n\n        * **files** - _integer_ - For multipart forms, the max number of file fields (Default: Infinity).\n\n        * **parts** - _integer_ - For multipart forms, the max number of parts (fields + files) (Default: Infinity).\n\n        * **headerPairs** - _integer_ - For multipart forms, the max number of header key=>value pairs to parse **Default:** 2000 (same as node's http).\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/mscdex/busboy/issues"
  },
  "homepage": "https://github.com/mscdex/busboy",
  "_id": "busboy@0.0.14",
  "_from": "busboy@0.0.14"
}
